/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * HQ
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration?: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AttachWindowCommand
 */
export interface AttachWindowCommand {
    /**
     * 
     * @type {string}
     * @memberof AttachWindowCommand
     */
    serviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachWindowCommand
     */
    windowId?: string;
}
/**
 * 
 * @export
 * @interface AttachedService
 */
export interface AttachedService {
    /**
     * 
     * @type {string}
     * @memberof AttachedService
     */
    id?: string;
    /**
     * 
     * @type {Array<CultureString>}
     * @memberof AttachedService
     */
    name?: Array<CultureString>;
}
/**
 * 
 * @export
 * @interface AvailableCultureResponse
 */
export interface AvailableCultureResponse {
    /**
     * 
     * @type {string}
     * @memberof AvailableCultureResponse
     */
    culture?: string;
    /**
     * 
     * @type {string}
     * @memberof AvailableCultureResponse
     */
    languageName?: string;
}
/**
 * 
 * @export
 * @interface ChangeRequestStatusCalledCommand
 */
export interface ChangeRequestStatusCalledCommand {
    /**
     * 
     * @type {string}
     * @memberof ChangeRequestStatusCalledCommand
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangeRequestStatusCalledCommand
     */
    calledByWindowId?: string;
}
/**
 * 
 * @export
 * @interface ChangeRequestStatusLostedCommand
 */
export interface ChangeRequestStatusLostedCommand {
    /**
     * 
     * @type {string}
     * @memberof ChangeRequestStatusLostedCommand
     */
    requestId?: string;
}
/**
 * 
 * @export
 * @interface ChangeRequestStatusWorkEndedCommand
 */
export interface ChangeRequestStatusWorkEndedCommand {
    /**
     * 
     * @type {string}
     * @memberof ChangeRequestStatusWorkEndedCommand
     */
    requestId?: string;
}
/**
 * 
 * @export
 * @interface ChangeRequestStatusWorkStartedCommand
 */
export interface ChangeRequestStatusWorkStartedCommand {
    /**
     * 
     * @type {string}
     * @memberof ChangeRequestStatusWorkStartedCommand
     */
    requestId?: string;
}
/**
 * 
 * @export
 * @interface CreateChildServiceCommand
 */
export interface CreateChildServiceCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateChildServiceCommand
     */
    parentServiceId?: string;
    /**
     * 
     * @type {Array<CultureString>}
     * @memberof CreateChildServiceCommand
     */
    name?: Array<CultureString>;
    /**
     * 
     * @type {string}
     * @memberof CreateChildServiceCommand
     */
    literal?: string;
}
/**
 * 
 * @export
 * @interface CreateQueueCommand
 */
export interface CreateQueueCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateQueueCommand
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateQueueCommand
     */
    culture?: string;
}
/**
 * 
 * @export
 * @interface CreateServiceCommand
 */
export interface CreateServiceCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateServiceCommand
     */
    queueId?: string;
    /**
     * 
     * @type {Array<CultureString>}
     * @memberof CreateServiceCommand
     */
    name?: Array<CultureString>;
    /**
     * 
     * @type {string}
     * @memberof CreateServiceCommand
     */
    literal?: string;
}
/**
 * 
 * @export
 * @interface CreateTerminalCommand
 */
export interface CreateTerminalCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateTerminalCommand
     */
    queueId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTerminalCommand
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTerminalCommand
     */
    externalPrinterId?: string;
}
/**
 * 
 * @export
 * @interface CreateWindowCommand
 */
export interface CreateWindowCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateWindowCommand
     */
    queueId?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateWindowCommand
     */
    number?: number;
}
/**
 * 
 * @export
 * @interface CultureString
 */
export interface CultureString {
    /**
     * 
     * @type {string}
     * @memberof CultureString
     */
    culture?: string;
    /**
     * 
     * @type {string}
     * @memberof CultureString
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface CurrentRequestResponse
 */
export interface CurrentRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof CurrentRequestResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentRequestResponse
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentRequestResponse
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentRequestResponse
     */
    culture?: string;
    /**
     * 
     * @type {RequestStatus}
     * @memberof CurrentRequestResponse
     */
    status?: RequestStatus;
    /**
     * 
     * @type {Date}
     * @memberof CurrentRequestResponse
     */
    createdDate?: Date;
}
/**
 * 
 * @export
 * @interface DeattachWindowCommand
 */
export interface DeattachWindowCommand {
    /**
     * 
     * @type {string}
     * @memberof DeattachWindowCommand
     */
    serviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof DeattachWindowCommand
     */
    windowId?: string;
}
/**
 * 
 * @export
 * @interface QueueResponse
 */
export interface QueueResponse {
    /**
     * 
     * @type {string}
     * @memberof QueueResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueResponse
     */
    defaultCulture?: string;
    /**
     * 
     * @type {Array<QueueTerminalResponse>}
     * @memberof QueueResponse
     */
    terminals?: Array<QueueTerminalResponse>;
    /**
     * 
     * @type {Array<QueueWindowResponse>}
     * @memberof QueueResponse
     */
    windows?: Array<QueueWindowResponse>;
    /**
     * 
     * @type {Array<QueueServiceResponse>}
     * @memberof QueueResponse
     */
    services?: Array<QueueServiceResponse>;
}
/**
 * 
 * @export
 * @interface QueueServiceResponse
 */
export interface QueueServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof QueueServiceResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueServiceResponse
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof QueueServiceResponse
     */
    requestNumberCounter?: number;
    /**
     * 
     * @type {string}
     * @memberof QueueServiceResponse
     */
    literal?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueServiceResponse
     */
    parentId?: string;
    /**
     * 
     * @type {string[]}
     * @memberof QueueServiceResponse
     */
    linkedWindowsIds: string[];
    /**
     * 
     * @type {Array<QueueServiceResponse>}
     * @memberof QueueServiceResponse
     */
    childs?: Array<QueueServiceResponse>;
}
/**
 * 
 * @export
 * @interface QueueTerminalResponse
 */
export interface QueueTerminalResponse {
    /**
     * 
     * @type {string}
     * @memberof QueueTerminalResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueTerminalResponse
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface QueueWindowResponse
 */
export interface QueueWindowResponse {
    /**
     * 
     * @type {string}
     * @memberof QueueWindowResponse
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof QueueWindowResponse
     */
    number?: number;
}
/**
 * 
 * @export
 * @interface QueuesResponse
 */
export interface QueuesResponse {
    /**
     * 
     * @type {string}
     * @memberof QueuesResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueuesResponse
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface RequestCalledResponse
 */
export interface RequestCalledResponse {
    /**
     * 
     * @type {string}
     * @memberof RequestCalledResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestCalledResponse
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestCalledResponse
     */
    culture?: string;
    /**
     * 
     * @type {Date}
     * @memberof RequestCalledResponse
     */
    createdDate?: Date;
    /**
     * 
     * @type {TabloWindowResponse}
     * @memberof RequestCalledResponse
     */
    window?: TabloWindowResponse;
}
/**
 * 
 * @export
 * @interface RequestResponse
 */
export interface RequestResponse {
    /**
     * 
     * @type {string}
     * @memberof RequestResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestResponse
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestResponse
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestResponse
     */
    culture?: string;
    /**
     * 
     * @type {Date}
     * @memberof RequestResponse
     */
    createdDate?: Date;
    /**
     * 
     * @type {RequestStatus}
     * @memberof RequestResponse
     */
    status?: RequestStatus;
    /**
     * 
     * @type {number}
     * @memberof RequestResponse
     */
    windowNumber?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RequestResponse
     */
    isFirstView?: boolean;
}
/**
 * 
 * @export
 * @interface RequestStatus
 */
export interface RequestStatus {
    /**
     * 
     * @type {string}
     * @memberof RequestStatus
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof RequestStatus
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface RequestWaitingResponse
 */
export interface RequestWaitingResponse {
    /**
     * 
     * @type {string}
     * @memberof RequestWaitingResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestWaitingResponse
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestWaitingResponse
     */
    culture?: string;
    /**
     * 
     * @type {Date}
     * @memberof RequestWaitingResponse
     */
    createdDate?: Date;
}
/**
 * 
 * @export
 * @interface ResetQueueCommand
 */
export interface ResetQueueCommand {
    /**
     * 
     * @type {string}
     * @memberof ResetQueueCommand
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface TabloResponse
 */
export interface TabloResponse {
    /**
     * 
     * @type {Array<RequestWaitingResponse>}
     * @memberof TabloResponse
     */
    waiting?: Array<RequestWaitingResponse>;
    /**
     * 
     * @type {Array<RequestCalledResponse>}
     * @memberof TabloResponse
     */
    called?: Array<RequestCalledResponse>;
}
/**
 * 
 * @export
 * @interface TabloWindowResponse
 */
export interface TabloWindowResponse {
    /**
     * 
     * @type {string}
     * @memberof TabloWindowResponse
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof TabloWindowResponse
     */
    number?: number;
}
/**
 * 
 * @export
 * @interface TerminalCreateRequestCommand
 */
export interface TerminalCreateRequestCommand {
    /**
     * 
     * @type {string}
     * @memberof TerminalCreateRequestCommand
     */
    toServiceId?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalCreateRequestCommand
     */
    fromTerminalId?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalCreateRequestCommand
     */
    culture?: string;
}
/**
 * 
 * @export
 * @interface TerminalPrintRequestCommand
 */
export interface TerminalPrintRequestCommand {
    /**
     * 
     * @type {string}
     * @memberof TerminalPrintRequestCommand
     */
    terminalId?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalPrintRequestCommand
     */
    requestId?: string;
}
/**
 * 
 * @export
 * @interface TerminalRequestResponse
 */
export interface TerminalRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof TerminalRequestResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalRequestResponse
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalRequestResponse
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalRequestResponse
     */
    culture?: string;
    /**
     * 
     * @type {Date}
     * @memberof TerminalRequestResponse
     */
    createdDate?: Date;
}
/**
 * 
 * @export
 * @interface TerminalResponse
 */
export interface TerminalResponse {
    /**
     * 
     * @type {string}
     * @memberof TerminalResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalResponse
     */
    name?: string;
    /**
     * 
     * @type {Array<AvailableCultureResponse>}
     * @memberof TerminalResponse
     */
    availableCultures?: Array<AvailableCultureResponse>;
    /**
     * 
     * @type {Array<TerminalServiceResponse>}
     * @memberof TerminalResponse
     */
    services?: Array<TerminalServiceResponse>;
}
/**
 * 
 * @export
 * @interface TerminalServiceResponse
 */
export interface TerminalServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof TerminalServiceResponse
     */
    id?: string;
    /**
     * 
     * @type {Array<CultureString>}
     * @memberof TerminalServiceResponse
     */
    name?: Array<CultureString>;
    /**
     * 
     * @type {number}
     * @memberof TerminalServiceResponse
     */
    requestNumberCounter?: number;
    /**
     * 
     * @type {string}
     * @memberof TerminalServiceResponse
     */
    literal?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalServiceResponse
     */
    parentId?: string;
    /**
     * 
     * @type {Array<TerminalServiceResponse>}
     * @memberof TerminalServiceResponse
     */
    childs?: Array<TerminalServiceResponse>;
}
/**
 * 
 * @export
 * @interface UpdateQueueNameCommand
 */
export interface UpdateQueueNameCommand {
    /**
     * 
     * @type {string}
     * @memberof UpdateQueueNameCommand
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateQueueNameCommand
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface UpdateServiceLiteralCommand
 */
export interface UpdateServiceLiteralCommand {
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceLiteralCommand
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceLiteralCommand
     */
    litetal?: string;
}
/**
 * 
 * @export
 * @interface UpdateServiceNameCommand
 */
export interface UpdateServiceNameCommand {
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceNameCommand
     */
    id?: string;
    /**
     * 
     * @type {Array<CultureString>}
     * @memberof UpdateServiceNameCommand
     */
    name?: Array<CultureString>;
}
/**
 * 
 * @export
 * @interface UpdateTerminalCommand
 */
export interface UpdateTerminalCommand {
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalCommand
     */
    terminalId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalCommand
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTerminalCommand
     */
    externalPrinterId?: string;
}
/**
 * 
 * @export
 * @interface WaitingRequestResponse
 */
export interface WaitingRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof WaitingRequestResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WaitingRequestResponse
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof WaitingRequestResponse
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof WaitingRequestResponse
     */
    culture?: string;
    /**
     * 
     * @type {Date}
     * @memberof WaitingRequestResponse
     */
    createdDate?: Date;
}
/**
 * 
 * @export
 * @interface WindowResponse
 */
export interface WindowResponse {
    /**
     * 
     * @type {string}
     * @memberof WindowResponse
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof WindowResponse
     */
    number?: number;
    /**
     * 
     * @type {Array<AttachedService>}
     * @memberof WindowResponse
     */
    attachedServices?: Array<AttachedService>;
    /**
     * 
     * @type {CurrentRequestResponse}
     * @memberof WindowResponse
     */
    currentRequest?: CurrentRequestResponse;
    /**
     * 
     * @type {Array<WaitingRequestResponse>}
     * @memberof WindowResponse
     */
    waitingRequests?: Array<WaitingRequestResponse>;
}
/**
 * QueueApi - fetch parameter creator
 * @export
 */
export const QueueApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/Queue`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiQueueIdDelete.');
            }
            const localVarPath = `/api/Queue/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiQueueIdGet.');
            }
            const localVarPath = `/api/Queue/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateQueueCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueuePost(body?: CreateQueueCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Queue`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateQueueCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateQueueNameCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueuePut(body?: UpdateQueueNameCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Queue`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateQueueNameCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResetQueueCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueResetPost(body?: ResetQueueCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Queue/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetQueueCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueueApi - functional programming interface
 * @export
 */
export const QueueApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QueuesResponse>> {
            const localVarFetchArgs = QueueApiFetchParamCreator(configuration).apiQueueGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = QueueApiFetchParamCreator(configuration).apiQueueIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueueResponse> {
            const localVarFetchArgs = QueueApiFetchParamCreator(configuration).apiQueueIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateQueueCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueuePost(body?: CreateQueueCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = QueueApiFetchParamCreator(configuration).apiQueuePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateQueueNameCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueuePut(body?: UpdateQueueNameCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = QueueApiFetchParamCreator(configuration).apiQueuePut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ResetQueueCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueResetPost(body?: ResetQueueCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = QueueApiFetchParamCreator(configuration).apiQueueResetPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueueApi - factory interface
 * @export
 */
export const QueueApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueGet(options?: any) {
            return QueueApiFp(configuration).apiQueueGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueIdDelete(id: string, options?: any) {
            return QueueApiFp(configuration).apiQueueIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueIdGet(id: string, options?: any) {
            return QueueApiFp(configuration).apiQueueIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateQueueCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueuePost(body?: CreateQueueCommand, options?: any) {
            return QueueApiFp(configuration).apiQueuePost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateQueueNameCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueuePut(body?: UpdateQueueNameCommand, options?: any) {
            return QueueApiFp(configuration).apiQueuePut(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ResetQueueCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueueResetPost(body?: ResetQueueCommand, options?: any) {
            return QueueApiFp(configuration).apiQueueResetPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * QueueApi - object-oriented interface
 * @export
 * @class QueueApi
 * @extends {BaseAPI}
 */
export class QueueApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public apiQueueGet(options?: any) {
        return QueueApiFp(this.configuration).apiQueueGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public apiQueueIdDelete(id: string, options?: any) {
        return QueueApiFp(this.configuration).apiQueueIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public apiQueueIdGet(id: string, options?: any) {
        return QueueApiFp(this.configuration).apiQueueIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreateQueueCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public apiQueuePost(body?: CreateQueueCommand, options?: any) {
        return QueueApiFp(this.configuration).apiQueuePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UpdateQueueNameCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public apiQueuePut(body?: UpdateQueueNameCommand, options?: any) {
        return QueueApiFp(this.configuration).apiQueuePut(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ResetQueueCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public apiQueueResetPost(body?: ResetQueueCommand, options?: any) {
        return QueueApiFp(this.configuration).apiQueueResetPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ServiceApi - fetch parameter creator
 * @export
 */
export const ServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AttachWindowCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceAttachWindowPost(body?: AttachWindowCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Service/attach-window`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AttachWindowCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateChildServiceCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceChildPost(body?: CreateChildServiceCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Service/child`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateChildServiceCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeattachWindowCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceDeattachWindowPost(body?: DeattachWindowCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Service/deattach-window`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeattachWindowCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiServiceIdDelete.');
            }
            const localVarPath = `/api/Service/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateServiceCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicePost(body?: CreateServiceCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Service`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateServiceCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceRequestIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiServiceRequestIdGet.');
            }
            const localVarPath = `/api/Service/request/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateServiceLiteralCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceUpdateLiteralPut(body?: UpdateServiceLiteralCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Service/update-literal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateServiceLiteralCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateServiceNameCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceUpdateNamePut(body?: UpdateServiceNameCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Service/update-name`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateServiceNameCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceApi - functional programming interface
 * @export
 */
export const ServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AttachWindowCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceAttachWindowPost(body?: AttachWindowCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ServiceApiFetchParamCreator(configuration).apiServiceAttachWindowPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateChildServiceCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceChildPost(body?: CreateChildServiceCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ServiceApiFetchParamCreator(configuration).apiServiceChildPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DeattachWindowCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceDeattachWindowPost(body?: DeattachWindowCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ServiceApiFetchParamCreator(configuration).apiServiceDeattachWindowPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ServiceApiFetchParamCreator(configuration).apiServiceIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateServiceCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicePost(body?: CreateServiceCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ServiceApiFetchParamCreator(configuration).apiServicePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceRequestIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RequestResponse> {
            const localVarFetchArgs = ServiceApiFetchParamCreator(configuration).apiServiceRequestIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateServiceLiteralCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceUpdateLiteralPut(body?: UpdateServiceLiteralCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ServiceApiFetchParamCreator(configuration).apiServiceUpdateLiteralPut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateServiceNameCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceUpdateNamePut(body?: UpdateServiceNameCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ServiceApiFetchParamCreator(configuration).apiServiceUpdateNamePut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ServiceApi - factory interface
 * @export
 */
export const ServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AttachWindowCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceAttachWindowPost(body?: AttachWindowCommand, options?: any) {
            return ServiceApiFp(configuration).apiServiceAttachWindowPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateChildServiceCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceChildPost(body?: CreateChildServiceCommand, options?: any) {
            return ServiceApiFp(configuration).apiServiceChildPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DeattachWindowCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceDeattachWindowPost(body?: DeattachWindowCommand, options?: any) {
            return ServiceApiFp(configuration).apiServiceDeattachWindowPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceIdDelete(id: string, options?: any) {
            return ServiceApiFp(configuration).apiServiceIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateServiceCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicePost(body?: CreateServiceCommand, options?: any) {
            return ServiceApiFp(configuration).apiServicePost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceRequestIdGet(id: string, options?: any) {
            return ServiceApiFp(configuration).apiServiceRequestIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateServiceLiteralCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceUpdateLiteralPut(body?: UpdateServiceLiteralCommand, options?: any) {
            return ServiceApiFp(configuration).apiServiceUpdateLiteralPut(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateServiceNameCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceUpdateNamePut(body?: UpdateServiceNameCommand, options?: any) {
            return ServiceApiFp(configuration).apiServiceUpdateNamePut(body, options)(fetch, basePath);
        },
    };
};

/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
export class ServiceApi extends BaseAPI {
    /**
     * 
     * @param {AttachWindowCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServiceAttachWindowPost(body?: AttachWindowCommand, options?: any) {
        return ServiceApiFp(this.configuration).apiServiceAttachWindowPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreateChildServiceCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServiceChildPost(body?: CreateChildServiceCommand, options?: any) {
        return ServiceApiFp(this.configuration).apiServiceChildPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DeattachWindowCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServiceDeattachWindowPost(body?: DeattachWindowCommand, options?: any) {
        return ServiceApiFp(this.configuration).apiServiceDeattachWindowPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServiceIdDelete(id: string, options?: any) {
        return ServiceApiFp(this.configuration).apiServiceIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreateServiceCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServicePost(body?: CreateServiceCommand, options?: any) {
        return ServiceApiFp(this.configuration).apiServicePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServiceRequestIdGet(id: string, options?: any) {
        return ServiceApiFp(this.configuration).apiServiceRequestIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UpdateServiceLiteralCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServiceUpdateLiteralPut(body?: UpdateServiceLiteralCommand, options?: any) {
        return ServiceApiFp(this.configuration).apiServiceUpdateLiteralPut(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UpdateServiceNameCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServiceUpdateNamePut(body?: UpdateServiceNameCommand, options?: any) {
        return ServiceApiFp(this.configuration).apiServiceUpdateNamePut(body, options)(this.fetch, this.basePath);
    }

}
/**
 * TabloApi - fetch parameter creator
 * @export
 */
export const TabloApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} queueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTabloQueueIdGet(queueId: string, options: any = {}): FetchArgs {
            // verify required parameter 'queueId' is not null or undefined
            if (queueId === null || queueId === undefined) {
                throw new RequiredError('queueId','Required parameter queueId was null or undefined when calling apiTabloQueueIdGet.');
            }
            const localVarPath = `/api/Tablo/{queueId}`
                .replace(`{${"queueId"}}`, encodeURIComponent(String(queueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TabloApi - functional programming interface
 * @export
 */
export const TabloApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} queueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTabloQueueIdGet(queueId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TabloResponse> {
            const localVarFetchArgs = TabloApiFetchParamCreator(configuration).apiTabloQueueIdGet(queueId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TabloApi - factory interface
 * @export
 */
export const TabloApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} queueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTabloQueueIdGet(queueId: string, options?: any) {
            return TabloApiFp(configuration).apiTabloQueueIdGet(queueId, options)(fetch, basePath);
        },
    };
};

/**
 * TabloApi - object-oriented interface
 * @export
 * @class TabloApi
 * @extends {BaseAPI}
 */
export class TabloApi extends BaseAPI {
    /**
     * 
     * @param {string} queueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabloApi
     */
    public apiTabloQueueIdGet(queueId: string, options?: any) {
        return TabloApiFp(this.configuration).apiTabloQueueIdGet(queueId, options)(this.fetch, this.basePath);
    }

}
/**
 * TerminalApi - fetch parameter creator
 * @export
 */
export const TerminalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TerminalCreateRequestCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalCreateRequestPost(body?: TerminalCreateRequestCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Terminal/create-request`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TerminalCreateRequestCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalExternalPrintersGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/Terminal/external-printers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiTerminalIdDelete.');
            }
            const localVarPath = `/api/Terminal/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiTerminalIdGet.');
            }
            const localVarPath = `/api/Terminal/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTerminalCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalPost(body?: CreateTerminalCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Terminal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateTerminalCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TerminalPrintRequestCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalPrintRequestPost(body?: TerminalPrintRequestCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Terminal/print-request`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TerminalPrintRequestCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateTerminalCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalPut(body?: UpdateTerminalCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Terminal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateTerminalCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerminalApi - functional programming interface
 * @export
 */
export const TerminalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TerminalCreateRequestCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalCreateRequestPost(body?: TerminalCreateRequestCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TerminalRequestResponse> {
            const localVarFetchArgs = TerminalApiFetchParamCreator(configuration).apiTerminalCreateRequestPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalExternalPrintersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TerminalResponse> {
            const localVarFetchArgs = TerminalApiFetchParamCreator(configuration).apiTerminalExternalPrintersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TerminalApiFetchParamCreator(configuration).apiTerminalIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TerminalResponse> {
            const localVarFetchArgs = TerminalApiFetchParamCreator(configuration).apiTerminalIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateTerminalCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalPost(body?: CreateTerminalCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TerminalApiFetchParamCreator(configuration).apiTerminalPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TerminalPrintRequestCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalPrintRequestPost(body?: TerminalPrintRequestCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TerminalApiFetchParamCreator(configuration).apiTerminalPrintRequestPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateTerminalCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalPut(body?: UpdateTerminalCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TerminalApiFetchParamCreator(configuration).apiTerminalPut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TerminalApi - factory interface
 * @export
 */
export const TerminalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {TerminalCreateRequestCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalCreateRequestPost(body?: TerminalCreateRequestCommand, options?: any) {
            return TerminalApiFp(configuration).apiTerminalCreateRequestPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalExternalPrintersGet(options?: any) {
            return TerminalApiFp(configuration).apiTerminalExternalPrintersGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalIdDelete(id: string, options?: any) {
            return TerminalApiFp(configuration).apiTerminalIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalIdGet(id: string, options?: any) {
            return TerminalApiFp(configuration).apiTerminalIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateTerminalCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalPost(body?: CreateTerminalCommand, options?: any) {
            return TerminalApiFp(configuration).apiTerminalPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TerminalPrintRequestCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalPrintRequestPost(body?: TerminalPrintRequestCommand, options?: any) {
            return TerminalApiFp(configuration).apiTerminalPrintRequestPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateTerminalCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTerminalPut(body?: UpdateTerminalCommand, options?: any) {
            return TerminalApiFp(configuration).apiTerminalPut(body, options)(fetch, basePath);
        },
    };
};

/**
 * TerminalApi - object-oriented interface
 * @export
 * @class TerminalApi
 * @extends {BaseAPI}
 */
export class TerminalApi extends BaseAPI {
    /**
     * 
     * @param {TerminalCreateRequestCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public apiTerminalCreateRequestPost(body?: TerminalCreateRequestCommand, options?: any) {
        return TerminalApiFp(this.configuration).apiTerminalCreateRequestPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public apiTerminalExternalPrintersGet(options?: any) {
        return TerminalApiFp(this.configuration).apiTerminalExternalPrintersGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public apiTerminalIdDelete(id: string, options?: any) {
        return TerminalApiFp(this.configuration).apiTerminalIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public apiTerminalIdGet(id: string, options?: any) {
        return TerminalApiFp(this.configuration).apiTerminalIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreateTerminalCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public apiTerminalPost(body?: CreateTerminalCommand, options?: any) {
        return TerminalApiFp(this.configuration).apiTerminalPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TerminalPrintRequestCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public apiTerminalPrintRequestPost(body?: TerminalPrintRequestCommand, options?: any) {
        return TerminalApiFp(this.configuration).apiTerminalPrintRequestPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UpdateTerminalCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public apiTerminalPut(body?: UpdateTerminalCommand, options?: any) {
        return TerminalApiFp(this.configuration).apiTerminalPut(body, options)(this.fetch, this.basePath);
    }

}
/**
 * WindowApi - fetch parameter creator
 * @export
 */
export const WindowApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiWindowIdDelete.');
            }
            const localVarPath = `/api/Window/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiWindowIdGet.');
            }
            const localVarPath = `/api/Window/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateWindowCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowPost(body?: CreateWindowCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Window`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateWindowCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangeRequestStatusCalledCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusCalledPost(body?: ChangeRequestStatusCalledCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Window/request/status-called`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeRequestStatusCalledCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangeRequestStatusLostedCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusLostedPost(body?: ChangeRequestStatusLostedCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Window/request/status-losted`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeRequestStatusLostedCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangeRequestStatusWorkEndedCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusWorkEndedPost(body?: ChangeRequestStatusWorkEndedCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Window/request/status-work-ended`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeRequestStatusWorkEndedCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangeRequestStatusWorkStartedCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusWorkStartedPost(body?: ChangeRequestStatusWorkStartedCommand, options: any = {}): FetchArgs {
            const localVarPath = `/api/Window/request/status-work-started`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeRequestStatusWorkStartedCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WindowApi - functional programming interface
 * @export
 */
export const WindowApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WindowApiFetchParamCreator(configuration).apiWindowIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WindowResponse> {
            const localVarFetchArgs = WindowApiFetchParamCreator(configuration).apiWindowIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateWindowCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowPost(body?: CreateWindowCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WindowApiFetchParamCreator(configuration).apiWindowPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ChangeRequestStatusCalledCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusCalledPost(body?: ChangeRequestStatusCalledCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WindowApiFetchParamCreator(configuration).apiWindowRequestStatusCalledPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ChangeRequestStatusLostedCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusLostedPost(body?: ChangeRequestStatusLostedCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WindowApiFetchParamCreator(configuration).apiWindowRequestStatusLostedPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ChangeRequestStatusWorkEndedCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusWorkEndedPost(body?: ChangeRequestStatusWorkEndedCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WindowApiFetchParamCreator(configuration).apiWindowRequestStatusWorkEndedPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ChangeRequestStatusWorkStartedCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusWorkStartedPost(body?: ChangeRequestStatusWorkStartedCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WindowApiFetchParamCreator(configuration).apiWindowRequestStatusWorkStartedPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WindowApi - factory interface
 * @export
 */
export const WindowApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowIdDelete(id: string, options?: any) {
            return WindowApiFp(configuration).apiWindowIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowIdGet(id: string, options?: any) {
            return WindowApiFp(configuration).apiWindowIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateWindowCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowPost(body?: CreateWindowCommand, options?: any) {
            return WindowApiFp(configuration).apiWindowPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ChangeRequestStatusCalledCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusCalledPost(body?: ChangeRequestStatusCalledCommand, options?: any) {
            return WindowApiFp(configuration).apiWindowRequestStatusCalledPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ChangeRequestStatusLostedCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusLostedPost(body?: ChangeRequestStatusLostedCommand, options?: any) {
            return WindowApiFp(configuration).apiWindowRequestStatusLostedPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ChangeRequestStatusWorkEndedCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusWorkEndedPost(body?: ChangeRequestStatusWorkEndedCommand, options?: any) {
            return WindowApiFp(configuration).apiWindowRequestStatusWorkEndedPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ChangeRequestStatusWorkStartedCommand} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWindowRequestStatusWorkStartedPost(body?: ChangeRequestStatusWorkStartedCommand, options?: any) {
            return WindowApiFp(configuration).apiWindowRequestStatusWorkStartedPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * WindowApi - object-oriented interface
 * @export
 * @class WindowApi
 * @extends {BaseAPI}
 */
export class WindowApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WindowApi
     */
    public apiWindowIdDelete(id: string, options?: any) {
        return WindowApiFp(this.configuration).apiWindowIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WindowApi
     */
    public apiWindowIdGet(id: string, options?: any) {
        return WindowApiFp(this.configuration).apiWindowIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreateWindowCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WindowApi
     */
    public apiWindowPost(body?: CreateWindowCommand, options?: any) {
        return WindowApiFp(this.configuration).apiWindowPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ChangeRequestStatusCalledCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WindowApi
     */
    public apiWindowRequestStatusCalledPost(body?: ChangeRequestStatusCalledCommand, options?: any) {
        return WindowApiFp(this.configuration).apiWindowRequestStatusCalledPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ChangeRequestStatusLostedCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WindowApi
     */
    public apiWindowRequestStatusLostedPost(body?: ChangeRequestStatusLostedCommand, options?: any) {
        return WindowApiFp(this.configuration).apiWindowRequestStatusLostedPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ChangeRequestStatusWorkEndedCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WindowApi
     */
    public apiWindowRequestStatusWorkEndedPost(body?: ChangeRequestStatusWorkEndedCommand, options?: any) {
        return WindowApiFp(this.configuration).apiWindowRequestStatusWorkEndedPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ChangeRequestStatusWorkStartedCommand} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WindowApi
     */
    public apiWindowRequestStatusWorkStartedPost(body?: ChangeRequestStatusWorkStartedCommand, options?: any) {
        return WindowApiFp(this.configuration).apiWindowRequestStatusWorkStartedPost(body, options)(this.fetch, this.basePath);
    }

}
